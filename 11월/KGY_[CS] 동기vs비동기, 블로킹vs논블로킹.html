<div class="tt_article_useless_p_margin contents_style"><p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1262" data-origin-height="469" style="margin-left: calc(50% - 340px); width: 680px;"><span data-url="https://blog.kakaocdn.net/dn/wj5Qa/btsAquLTEbQ/IrXxjZXRAFnuMwkEG3daGk/img.png" data-lightbox="lightbox" style="padding-bottom: 37.2059%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="680" height="253" data-origin-width="1262" data-origin-height="469" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/wj5Qa/btsAquLTEbQ/IrXxjZXRAFnuMwkEG3daGk/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fwj5Qa%2FbtsAquLTEbQ%2FIrXxjZXRAFnuMwkEG3daGk%2Fimg.png" data-sizes="auto" sizes="680px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fwj5Qa%2FbtsAquLTEbQ%2FIrXxjZXRAFnuMwkEG3daGk%2Fimg.png" src="https://blog.kakaocdn.net/dn/wj5Qa/btsAquLTEbQ/IrXxjZXRAFnuMwkEG3daGk/img.png"></span></figure>
<p></p>
<h2 data-ke-size="size26" id="0.%20%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%A0%84-1"><a href="#0.%20%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%A0%84-1">0. 들어가기전</a></h2>
<p data-ke-size="size16">동기/비동기 와 블로킹/논블로킹 의 개념은 비슷해 보일지라도 서로 다른 차원에서 작업의 수행 방식을 설명하는 개념이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>동기/비동기</b></span> : 처리해야 할 작업들을 수행 방식(완료 여부)의 차이</p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>블로킹/논블로킹</b></span> : 처리해야할 작업의 과정의 제어권 처리 방법의 차이</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그렇기 때문에 동기 != 블로킹, 비동기 != 논블로킹 이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26" id="1.%20%EB%8F%99%EA%B8%B0(Sync)%20vs%20%EB%B9%84%EB%8F%99%EA%B8%B0(Async)-1"><a href="#1.%20%EB%8F%99%EA%B8%B0(Sync)%20vs%20%EB%B9%84%EB%8F%99%EA%B8%B0(Async)-1">1. 동기(Sync) vs 비동기(Async)</a></h2>
<p data-ke-size="size16">동기와 비동기를 구분하는 방법은 처리해야 할 작업들에 대한</p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>작업 순서 처리의 차이</b><span style="color: #000000;">이다</span></span></p>
<p data-ke-size="size16">.</p>
<p data-ke-size="size16">요청한 작업에 대해 완료 여부를 따져 순차대로 처리한다면 <span style="color: #ef5369;"><b>동기</b></span>,</p>
<p data-ke-size="size16">요청한 작업에 대해 완료 여부를 따지지 않는다면 <span style="color: #ef5369;"><b>비동기</b></span>이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>1. 동기</b></h4>
<p data-ke-size="size16">호출된 작업의 리턴하는 시간과 결과를 반환하는 시간이 일치하는 경우를 말한다.</p>
<p data-ke-size="size16">작업 A의 종료시간과 작업 B의 시작시간이 같으면 <span style="color: #ef5369;"><b>동기적</b></span>이라고 한다.</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1200" data-origin-height="181" style="margin-left: calc(50% - 331px); width: 662px;"><span data-url="https://blog.kakaocdn.net/dn/FbfP0/btsArzTtpYk/gEuNmpyUkLwqu5aJATlzwk/img.png" data-lightbox="lightbox" style="padding-bottom: 15.1057%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="662" height="100" data-origin-width="1200" data-origin-height="181" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/FbfP0/btsArzTtpYk/gEuNmpyUkLwqu5aJATlzwk/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFbfP0%2FbtsArzTtpYk%2FgEuNmpyUkLwqu5aJATlzwk%2Fimg.png" data-sizes="auto" sizes="662px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFbfP0%2FbtsArzTtpYk%2FgEuNmpyUkLwqu5aJATlzwk%2Fimg.png" src="https://blog.kakaocdn.net/dn/FbfP0/btsArzTtpYk/gEuNmpyUkLwqu5aJATlzwk/img.png"></span></figure>
<p></p>
<h4 data-ke-size="size20"><b>2. 비동기</b></h4>
<p data-ke-size="size16">호출된 작업의 리턴하는 시간과 결과를 반환하는 시간이 일치하지 않는 경우를 말한다.</p>
<p data-ke-size="size16">동기와 반대로 대상이 작업시간이 같지 않을 때 <span style="color: #ef5369;"><b>비동기적</b></span>이라고 한다.</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1200" data-origin-height="252" style="margin-left: calc(50% - 323px); width: 646px;"><span data-url="https://blog.kakaocdn.net/dn/39979/btsAmqcWwKH/Q34VdHpq4bJBuYDONpefnk/img.png" data-lightbox="lightbox" style="padding-bottom: 21.0526%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="646" height="136" data-origin-width="1200" data-origin-height="252" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/39979/btsAmqcWwKH/Q34VdHpq4bJBuYDONpefnk/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F39979%2FbtsAmqcWwKH%2FQ34VdHpq4bJBuYDONpefnk%2Fimg.png" data-sizes="auto" sizes="646px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F39979%2FbtsAmqcWwKH%2FQ34VdHpq4bJBuYDONpefnk%2Fimg.png" src="https://blog.kakaocdn.net/dn/39979/btsAmqcWwKH/Q34VdHpq4bJBuYDONpefnk/img.png"></span></figure>
<p></p>
<h2 data-ke-size="size26" id="2.%20%EB%B8%94%EB%A1%9C%ED%82%B9(Blocking)%20vs%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9(Non-Blocking)-1"><a href="#2.%20%EB%B8%94%EB%A1%9C%ED%82%B9(Blocking)%20vs%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9(Non-Blocking)-1">2. 블로킹(Blocking) vs 논블로킹(Non-Blocking)</a></h2>
<p data-ke-size="size16">블로킹과 논블로킹의 차이는 다른 요청의 작업을 처리하기 위해 <span style="color: #ef5369;"><b>현재 작업을 block(차단, 대기) 하냐, 안 하냐</b></span>의 유무를 나타내는 프로세스의 실행 방식이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>1. 블로킹(Blocking)</b></h4>
<p data-ke-size="size16">블로킹은 A함수가 B함수를 호출하면, <span style="color: #ef5369;"><b>제어권을 A가 호출한 B 함수에 넘겨주는 것</b></span>이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="517" data-origin-height="539" style="width: 290px;"><span data-url="https://blog.kakaocdn.net/dn/bDD5zn/btsAkshzjEV/QxlKkE1kCNc1T9OG9EI5m1/img.png" data-lightbox="lightbox" style="padding-bottom: 104.255%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="290" data-origin-width="517" data-origin-height="539" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/bDD5zn/btsAkshzjEV/QxlKkE1kCNc1T9OG9EI5m1/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbDD5zn%2FbtsAkshzjEV%2FQxlKkE1kCNc1T9OG9EI5m1%2Fimg.png" data-sizes="auto" sizes="290px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbDD5zn%2FbtsAkshzjEV%2FQxlKkE1kCNc1T9OG9EI5m1%2Fimg.png" src="https://blog.kakaocdn.net/dn/bDD5zn/btsAkshzjEV/QxlKkE1kCNc1T9OG9EI5m1/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">1. A가 B를 호출하면, A가 B에게 제어권을 넘긴다.</p>
<p data-ke-size="size16">2. 제어권을 넘겨받은 B는 함수를 실행한다. A는 함수 실행을 멈춘다. (Block)</p>
<p data-ke-size="size16">3. B는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>2. 논블로킹(Non-Blocking)</b></h4>
<p data-ke-size="size16">논블로킹은 A함수가 B함수를 호출해도 <span style="color: #ef5369;"><b>제어권은 그대로 자신이 가지고 있는 것</b></span>이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="480" data-origin-height="540" style="width: 268px;"><span data-url="https://blog.kakaocdn.net/dn/esP2nx/btsAs6jbPJ5/oQQFfnkIIys6FUOmxNTqvK/img.png" data-lightbox="lightbox" style="padding-bottom: 112.5%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="268" data-origin-width="480" data-origin-height="540" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/esP2nx/btsAs6jbPJ5/oQQFfnkIIys6FUOmxNTqvK/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FesP2nx%2FbtsAs6jbPJ5%2FoQQFfnkIIys6FUOmxNTqvK%2Fimg.png" data-sizes="auto" sizes="268px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FesP2nx%2FbtsAs6jbPJ5%2FoQQFfnkIIys6FUOmxNTqvK%2Fimg.png" src="https://blog.kakaocdn.net/dn/esP2nx/btsAs6jbPJ5/oQQFfnkIIys6FUOmxNTqvK/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">1. A가 B를 호출하면, B는 실행되지만 제어권은 A가 그대로 가지고 있는다.</p>
<p data-ke-size="size16">2. A가 계속 제어권을 가지고 있기 때문에 B를 호출한 이후에도 자신의 코드를 계속 실행한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26" id="3.%20%EB%8F%99%EA%B8%B0%2F%EB%B9%84%EB%8F%99%EA%B8%B0%20%2B%20%EB%B8%94%EB%A1%9C%ED%82%B9%2F%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9%20%EC%A1%B0%ED%95%A9-1"><a href="#3.%20%EB%8F%99%EA%B8%B0%2F%EB%B9%84%EB%8F%99%EA%B8%B0%20%2B%20%EB%B8%94%EB%A1%9C%ED%82%B9%2F%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9%20%EC%A1%B0%ED%95%A9-1">3. 동기/비동기 + 블로킹/논블로킹 조합</a></h2>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="690" data-origin-height="385" style="width: 496px;"><span data-url="https://blog.kakaocdn.net/dn/NyhEW/btsAjOE8iaw/eROZm6DXpu8aIVk7v0ay8K/img.png" data-lightbox="lightbox" style="padding-bottom: 55.7971%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="496" data-origin-width="690" data-origin-height="385" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/NyhEW/btsAjOE8iaw/eROZm6DXpu8aIVk7v0ay8K/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNyhEW%2FbtsAjOE8iaw%2FeROZm6DXpu8aIVk7v0ay8K%2Fimg.png" data-sizes="auto" sizes="496px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNyhEW%2FbtsAjOE8iaw%2FeROZm6DXpu8aIVk7v0ay8K%2Fimg.png" src="https://blog.kakaocdn.net/dn/NyhEW/btsAjOE8iaw/eROZm6DXpu8aIVk7v0ay8K/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">동기/비동기 와 블로킹/논블로킹 은 유사하지만 엄연히 다른 개념이다.</p>
<p data-ke-size="size16">그래서 프로그램 아키텍쳐에서는 이 두 개념이 함께 조합되어 사용된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>1. Sync Blocking (동기 + 블로킹)</b></span></p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>2. Async Blocking (비동기 + 블로킹)</b></span></p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>3. Sync Non-Blocking (동기 + 논블로킹)</b></span></p>
<p data-ke-size="size16"><span style="color: #ef5369;"><b>4. Async Non-Blocking (비동기 + 논블로킹)</b></span></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="background-color: #ffc1c8;"><b>1. Sync Blocking (동기 + 블로킹)</b></span></h4>
<p data-ke-size="size16">다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고(<span style="color: #ef5369;"><b>Blocking</b></span>), 다른 작업의 완료 여부를 바로 받아 순차적으로 처리(<span style="color: #ef5369;"><b>Sync</b></span>)하는 방식이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="549" data-origin-height="571" style="width: 272px;"><span data-url="https://blog.kakaocdn.net/dn/Dli9z/btsAmCxp8rL/i9N2vkgVtBS8y0Giw6ey4k/img.png" data-lightbox="lightbox" style="padding-bottom: 104.007%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="272" data-origin-width="549" data-origin-height="571" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/Dli9z/btsAmCxp8rL/i9N2vkgVtBS8y0Giw6ey4k/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDli9z%2FbtsAmCxp8rL%2Fi9N2vkgVtBS8y0Giw6ey4k%2Fimg.png" data-sizes="auto" sizes="272px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDli9z%2FbtsAmCxp8rL%2Fi9N2vkgVtBS8y0Giw6ey4k%2Fimg.png" src="https://blog.kakaocdn.net/dn/Dli9z/btsAmCxp8rL/i9N2vkgVtBS8y0Giw6ey4k/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">1. A는 B의 리턴값을 필요로 한다. (Sync)</p>
<p data-ke-size="size16">2. 제어권을 B에게 넘겨준다.</p>
<p data-ke-size="size16">3. A는 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 기다린다. (Blocking)</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">주로 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용할 수 있다.</p>
<p data-ke-size="size16">Sync Blocking 조합은 <span style="color: #ef5369;"><b>코드가 순차적으로 실행</b></span>되는 특성을 가지고 있기 때문에, 작업이 간단하거나 작업량이 적은 경우에 사용된다.</p>
<pre id="code_1700079109726" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// 파일 시스템 모듈 불러오기</span>

<span class="hljs-comment">// 동기적으로 파일 읽기</span>
<span class="hljs-keyword">const</span> data1 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'file1.txt'</span>, <span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// file1을 sync으로 read 함</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1); <span class="hljs-comment">// 파일 내용 출력하고 적절한 처리를 진행</span>

<span class="hljs-keyword">const</span> data2 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'file2.txt'</span>, <span class="hljs-string">'utf8'</span>); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data2); 

<span class="hljs-keyword">const</span> data3 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'file3.txt'</span>, <span class="hljs-string">'utf8'</span>); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data3);</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">예를 들어, C나 Java의 코드 실행 후 cmd에서 입력을 받는 경우가 해당된다.</p>
<p data-ke-size="size16">사용자로부터 입력을 받아야 그 입력값을 가지고 내부 처리를 하여 결과값을 콘솔에 출력해주기 때문에 순차적인 작업이 요구된다.</p>
<p data-ke-size="size16">또한, 실행 코드가 콘솔창을 띄우고, 텍스트를 치고 난 다음 사용자로부터 리턴값을 필요로하기 때문에 제어권을 시스템에서 사용자로 넘겨 사용자가 값을 입력할 때까지 기다리는 것이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-filename="스크린샷 2023-11-16 오전 4.36.40.png" data-origin-width="1124" data-origin-height="510" style="width: 392px;"><span data-url="https://blog.kakaocdn.net/dn/biLAzH/btsAqHR1fnZ/iIP8xRF5cA0zAxRNrJd0a0/img.png" data-lightbox="lightbox" style="padding-bottom: 45.4082%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="392" height="178" data-filename="스크린샷 2023-11-16 오전 4.36.40.png" data-origin-width="1124" data-origin-height="510" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/biLAzH/btsAqHR1fnZ/iIP8xRF5cA0zAxRNrJd0a0/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbiLAzH%2FbtsAqHR1fnZ%2FiIP8xRF5cA0zAxRNrJd0a0%2Fimg.png" data-sizes="auto" sizes="392px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbiLAzH%2FbtsAqHR1fnZ%2FiIP8xRF5cA0zAxRNrJd0a0%2Fimg.png" src="https://blog.kakaocdn.net/dn/biLAzH/btsAqHR1fnZ/iIP8xRF5cA0zAxRNrJd0a0/img.png"></span></figure>
<p></p>
<h4 data-ke-size="size20"><b>2. Async Blocking (비동기 + 블로킹)</b></h4>
<p data-ke-size="size16">다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리는(Blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 (Async) 방식이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="564" data-origin-height="583" style="width: 280px;"><span data-url="https://blog.kakaocdn.net/dn/sKCF9/btsArk94YIe/AvbuqFzyr6D0KDnmUku9S1/img.png" data-lightbox="lightbox" style="padding-bottom: 103.214%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="280" height="289" data-origin-width="564" data-origin-height="583" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/sKCF9/btsArk94YIe/AvbuqFzyr6D0KDnmUku9S1/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsKCF9%2FbtsArk94YIe%2FAvbuqFzyr6D0KDnmUku9S1%2Fimg.png" data-sizes="auto" sizes="280px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsKCF9%2FbtsArk94YIe%2FAvbuqFzyr6D0KDnmUku9S1%2Fimg.png" src="https://blog.kakaocdn.net/dn/sKCF9/btsArk94YIe/AvbuqFzyr6D0KDnmUku9S1/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">1. A는 B의 리턴값에 신경쓰지 않고 콜백함수를 보낸다. (Async)</p>
<p data-ke-size="size16">2. A는 B의 작업에 관심없음에도 불구하고, B에게 제어권을 넘긴다. (Blocking)</p>
<p data-ke-size="size16">3. A는 자신과 관련 없는 B의 작업이 끝날 때까지 기다린다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">Async Blocking 조합은 비효율적이라서 사용되는 모델이 많지 않다.</p>
<h4 data-ke-size="size20"><b>3. Sync Non-Blocking (동기 + 논블로킹)</b></h4>
<p data-ke-size="size16">다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (<span style="color: #ef5369;"><b>Non Blocking</b></span>), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행(<span style="color: #ef5369;"><b>Sync</b></span>)하는 방식이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="534" data-origin-height="543" style="width: 294px;"><span data-url="https://blog.kakaocdn.net/dn/bdYsg4/btsAmA0G5yx/nMMGtFpipK3EwN44jIfw41/img.png" data-lightbox="lightbox" style="padding-bottom: 101.701%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="294" height="299" data-origin-width="534" data-origin-height="543" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/bdYsg4/btsAmA0G5yx/nMMGtFpipK3EwN44jIfw41/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbdYsg4%2FbtsAmA0G5yx%2FnMMGtFpipK3EwN44jIfw41%2Fimg.png" data-sizes="auto" sizes="294px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbdYsg4%2FbtsAmA0G5yx%2FnMMGtFpipK3EwN44jIfw41%2Fimg.png" src="https://blog.kakaocdn.net/dn/bdYsg4/btsAmA0G5yx/nMMGtFpipK3EwN44jIfw41/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">1. A는 B를 호출한다.</p>
<p data-ke-size="size16">2. 이때 A는 B에게 제어권을 주지 않고, 자신의 코드를 계속 실행한다. (Non-Blocking)</p>
<p data-ke-size="size16">3. A는 B의 리턴값이 필요하기 때문에 중간중간 B에게 함수 실행을 완료했는지 물어본다. (Sync)</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">Sync Non-Blocking 조합의 예를 들자면, 게임에서 맵을 이동할 때 뜨는 로딩 화면과 같다. 맵을 불러오기 위한 맵 데이터를 다운 받는 동안 로딩 스크린은 로딩바가 채워지는 프로그램을 수핸한다. 즉, 제어권은 여전히 나한테 있어 화면에 로드율이 표시되는 것이다. 그리고 끊임없이 맵 데이터가 어느정도 로드 됐는지 조회한다.</p>
<h4 data-ke-size="size20"><span style="background-color: #ffc1c8;"><b>4. Async Non-Blocking (비동기 + 논블로킹)</b></span></h4>
<p data-ke-size="size16">다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non-Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 (Async) 방식이다.</p>
<p></p><figure class="imageblock alignLeft" data-ke-mobilestyle="widthOrigin" data-origin-width="464" data-origin-height="540" style="width: 257px;"><span data-url="https://blog.kakaocdn.net/dn/Hveyz/btsAqxhzBUr/aKoMhNkeOrR6kBjdUCoZF1/img.png" data-lightbox="lightbox" style="padding-bottom: 116.379%;"><img onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="257" data-origin-width="464" data-origin-height="540" class="lazyautosizes lazyloaded" data-src="https://blog.kakaocdn.net/dn/Hveyz/btsAqxhzBUr/aKoMhNkeOrR6kBjdUCoZF1/img.png" data-srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHveyz%2FbtsAqxhzBUr%2FaKoMhNkeOrR6kBjdUCoZF1%2Fimg.png" data-sizes="auto" sizes="257px" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHveyz%2FbtsAqxhzBUr%2FaKoMhNkeOrR6kBjdUCoZF1%2Fimg.png" src="https://blog.kakaocdn.net/dn/Hveyz/btsAqxhzBUr/aKoMhNkeOrR6kBjdUCoZF1/img.png"></span></figure>
<p></p>
<p data-ke-size="size16">1. A는 B를 호출한다.</p>
<p data-ke-size="size16">2. 이때 A는 B에게 제어권을 주지 않는다(Non-Blocking)</p>
<p data-ke-size="size16">3. A는 B를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행한다.</p>
<p data-ke-size="size16">4. A는 B를 호출할 때 콜백함수도 함께 넘긴다.</p>
<p data-ke-size="size16">5. B는 자신의 작업이 끝나면 A가 준 콜백 함수를 실행한다(Async)</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">Async Non-Blocking 조합은&nbsp;<span style="color: #ef5369;"><b>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우</b></span>에 활용할 수 있다.</p>
<pre id="code_1700079077570" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code class="hljs language-javascript"><span class="hljs-comment">// 비동기적으로 파일 읽기</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>); <span class="hljs-comment">// 파일 시스템 모듈 불러오기</span>

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> { <span class="hljs-comment">// 파일 읽기 요청과 콜백 함수 전달</span>
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 에러 처리</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 파일 내용 출력</span>
});

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'file2.txt'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err; 
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'file3.txt'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> { 
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err; 
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>); <span class="hljs-comment">// 작업 완료 메시지 출력</span></code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">위의 Sync Blocking 파일 읽기 코드와 다르게 Async Non-Blocking 코드는</p>
<p data-ke-size="size16">'done' 이라는 콘솔이 가장 먼저 찍히고, 그 후에 파일 내용이 출력될 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이처럼 Async Non-Blocking 조합은 <span style="color: #ef5369;"><b>작업량이 많거나 시간이 오래 걸리는 작업을 처리</b></span>해야 하는 경우에 적합하다.</p>
<p data-ke-size="size16">예를 들어, 대용량 데이터를 처리하거나 많은 요청을 처리하는 서비스에서는 비동기 + 논블로킹 방식을 사용하여 한 작업이 처리되는 동안 다른 작업을 처리할 수 있으므로 전체 처리 시간을 줄일 수 있어 어플리케이션 처리 성능을 향상시킬 수 있게 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹 브라우저의 파일 다운로드가 비동기 + 논블로킹 조합의 가장 대표적인 예시이다.</p>
<p data-ke-size="size16">웹 브라우저는 웹 사이트에서 파일을 다운로드할 때, 파일의 전송이 완료될 때까지 다른 작업을 하지 않고 기다리는 것이 아니라, 다른 탭이나 창을 열거나 웹 서핑을 할 수 있다. 이는 웹 브라우저가 파일 다운로드를 비동기적으로 처리하고 콜백 함수를 통해 다운로드가 완료되면 알려주는 방식으로 구현되어 있기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>정리하자면...</b></h4>
<p data-ke-size="size16">우리가 자주 사용하는 javascript의 <code>setTimeout()</code> 함수는 <b>비동기 + 논블로킹</b> 함수이며,</p>
<p data-ke-size="size16">Node.js에서 비동기 방식으로 파일을 읽거나 네트워크 요청을 보낼 때는 <b>비동기 + 논블로킹</b> 방식을 사용하며,</p>
<p data-ke-size="size16">Node.js에서 코드 실행 시점을 늦춰주거나 순차적인 의존성이 있는 작업을 처리할 때는 <b>동기 + 블로킹</b> 방식을 사용한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이처럼 개념을 이해하고 적절한 조합을 선택한다면 작업의 순서와 타이밍을 제어할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p></div>