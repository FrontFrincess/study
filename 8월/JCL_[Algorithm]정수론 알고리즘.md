# 정수론 알고리즘 

> 정수론(Number Theory) 은 정수의 성질을 다루는 수학의 한 분야로 구체적으로 다른 수(유리수, 실수, 복소수) 들은 가지지 않는, 정수의 독특한 특징인 약수와 배수, 몫과 나머지 등에 대해 탐구하는 학문입니다. 우리는 알고리즘 문제를 풀 때 뿐만 아니라 암호학에 대한 원리(ex. 비대칭키 알고리즘 RSA) 를 이해하기 위해서 정수론에 대해 알아둘 필요가 있습니다. 

<br/>

오랜만에 알고리즘에 대해 공부를 시작한 나.. 모든 것을 다 까먹어버렸는데 ... 새로 시작하는 의미로 알고리즘 문제에서 자주 쓰이는 몇 가지만 알아보도록 하자 !! 

1)  유클리드 호제법 - 최대공약수, 최소공배수 
2)  에라토스테네스의 체 - 소수 
3)   n의 약수 구하기  - 약수 

<br/>

### 1. 유클리드 호제법  

> 유클리드 호제법이란 2개의 자연수 또는 정식의 최대공약수를 구하는 알고리즘의 하나이다.  2개의 자연수(혹은 정식)  a, b 에 대해서 a 를 b 로 나눈 나머지를 r 이라 하면 (단, a > b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다. 이 성질에 따라, b를 r 로 나눈 나머지 r 을 구하고, 다시 r 을 r 로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a 와 b 의 최대공약수이다. 

<br />

#### (1)GCD(최대공약수, Greatest Common Divisor) 

예를 들면, 172 와 26 의 최대공약수를 구한다고 해보자. 

여기서 172 는 a, 26 는 b에 해당할 것이다. 

##### 1. GCD(172, 26) 

- 여기서 GCD 는 최대공약수(Greatest Common Divisor) 을 의미함 
- 172 % 26 = 16 
- r 은 나머지인 16이 되고 이제 b 와 r 의 최대공약수를 구해보자 

##### 2. GCD(26, 16) 

- 26 % 16 = 10 

##### 3. GCD(16, 10) 

- 16 % 10 = 6 

##### 4.GCD(10, 6) 

- 10 % 6 = 4 

##### 5. GCD(6, 4) 

- 6 % 4 = 2 

##### 6. GCD(4, 2) 

- 4 % 2 = 0 
- 나머지가 0이 되었으니까 나누는 수인 2가 172 와 26의 최대공약수가 된다. 

즉, GCD(172, 26)  =  GCD(26, 16) = GCD(16, 10) = GCD(10, 6) = GCD(6, 4) = 2 

<br />

##### Python Code 

```python
# 1 
def gcd(a, b):
    while b != 0:
        a, b = b, a % b 
    return a 

# 2 
def gcd(a, b):
    while b != 0: 
        if a < b: 
            a, b = b, a
        if b == 0: 
            return a 
       	if a % b == 0:
            return b
# 3         
def gcd(a, b):
    if a < b:
        a, b = b, a 
    if b == 0: 
        return a 
    if a % b == 0:
        return b 
    else: return gcd(b, a % b) 
```

##### Javascript Code 

```javascript
// 단, a > b 
function gcd(a, b) {
	var r; 
	while ((a % b) < 0) {
		r = a % b; 
		a = b; 
		b = r; 
	}
	return b; 
}
```

<br/>

#### (2) LCM(Least Common Muliple), 최소공배수 

방금 구한 최대공약수가 G = GCD(a, b) 라고 하면 

a = Gx, b = Gy 가 되게 됩니다. 

즉, 최소공배수의 경우 Gxy 가 되게 되고  

LCM = a * b / G 가 되게 됩니다. 

<br/>

### 2. 에라토스테네스의 체 

- 소수를 구하는 효율적인 알고리즘으로 마치 체처럼 걸러낸다고 하여 이름 붙인 이 알고리즘은, 2 이상 n 이하의 정수 x 가 소수인지 아닌지 효율적으로 판단할 수 있도록 추가적인 배열을 만드는 전처리 알고리즘이다. 

(1) 초기 배열(array)의 모든 값은 0으로 초기화되어 있음

(2) 2부터 차례대로 정수를 살펴보는데 2가 소수이기 때문에 2의 배수들은 array[x] = 1 로 전부 표시해놓는다. (array[x] 가 이미 1이었다면 건너뜀)

(3) 3은 0 이기 때문에 소수이기 때문에 3의 배수는 전부 1로 표시 

...  이런식으로 sqrt(n) 이하의 숫자까지 진행  (시간복잡도 O(sqrt(n))

이런 식으로 새로운 소수 x 를 발견할 때마다, 그의 배수들을 모두 소수가 아니라고 표시합니다. 

```python
import math 

n = 1000
sieve = [0 for i in range(n + 1)]

for i in range(2, int(math.sqrt(n)) + 1):
    if array[i] == 0:
    	for j in range(2 * i, n, i):
            array[j] = 1 
    
    
sieve = [i for i in range(2, n) if array[i] == 0] 
print(sieve) 
```

- 에라토스테네스의 체를 이용하면 소인수분해를 빠르게 할 수 있다. 

- 소수인 i 로 나누어 떨어진다면, 그 소수를 출력하고 n 을 그 소수로 나눈 후 다시 반복 하는 등 .. 

<br/>

### 3. n의 약수 구하기

- 물론 1 부터 n 까지의 숫자를 모두 반복문을 돌려 약수를 찾아내는 것도 좋겠지만 이렇게 되면 시간 복잡도는 O(n) 이 된다. 

- 이것보다 효율적으로 풀기 위해서는 n의 약수를 구하기 위해서는 1부터 n 제곱근까지의 수만 0으로 나누어 떨어지는 지 확인하면 된다. 

  예를 들어 설명을 하자면, 100의 약수를 구한다고 했을 때 100의 제곱근은 10이니까 1부터 10까지의 수만 100이 0으로 떨어지는 지 보면 된다. 

  100 % 1 = 0 

  100 % 2 = 0 

  100 % 3 = 1 

  100 % 4 = 0 

  100 % 5 = 0 

  100 % 6 = 4 

  100 % 7 = 2

  100 % 8 = 4 

  100 % 9 = 1 

  100 % 10 = 0 

  일단, 1 부터 10까지의 수로 볼 때 1, 2, 4, 5, 10 은 100의 약수가 된다. 이제 이렇게 구했다면 이 구한 수를 100으로 나눈 값을 추가로 약수에 더해주면 된다. 

  100 / 1 = 100 

  100 / 2 = 50 

  100 / 4 = 25 

  100 / 5 = 20 

  100 / 10 = 10 

  즉, 100의 약수는 1, 2, 4, 5, 10, 20, 25, 50, 100 이 된다. 

  이 경우에는 시간 복잡도가 O(√N) 이 되기 때문에 훨씬 효율적이다. 

##### Python Code 

```python 
import Math 
def divisor(n):
    data = []
    # 제곱근까지만 반복문을 돌림
    for i in range(1, int(Math.sqrt(n)) + 1):
    	if n % i == 0:
    		data.append(i)
    		data.append(n//i) 
    # set 으로 중복 제거 후 다시 리스트로 정렬해줌 
    return sorted(list(set(data)), reverse=True) 
```

##### Javascript Code 

```javascript
const divisors = (num) => {
    const data = [];
    for(let i = 0; i <= Math.sqrt(num); i++){
        if(num % i === 0) {
            data.push(i)
            // set 을 통한 중복 제거도 가능 
            if(num / i != i) data.push(num / i); 
        }
    }
    return data; 
}
```

<br/>

##### 참고 

https://velog.io/@yyeonggg/%EB%AA%A8%EB%93%88%EB%9F%AC-%EC%97%B0%EC%82%B0Modular-Arithmetic#%ED%8A%B9%EC%A7%95